//프로그래머스 algorithm Prob  
//생각  1.첫번째생각:      1을제외한 2의배수,3의배수,4의배수, ... 배수들을 차례로 제거해서 갯수를 구한다 ( 가장 처음 든 생각 이지만 알고리즘 구현 실패)
     // 2.두번째생각:      2부터 직접 일일이 나눠보면서 배수를 찾아 제외시킨다. (시간이 너무오래걸림)
     // 3.세번째 생각:      수열을 찾아내어 식으로 표현한뒤 코드한줄로 간단히 표현  : 일종의 코드 및 규칙성을 파악했지만, 찾아보니 실제로 암호구문 및 암호코드를 만들 때 수학              자들이 만들어내는 암호화 수열에 있어서 소수를 이용한다고함.. 놀랐음..
     // 4. 다 풀고 알게 된 내용인데, 첫 번째 생각은 이미 예전에 풀었던 수학문제 이며 에테? 무슨 xx텔레스? 의 체 라고함
     // 5. 실행이 되도 테스트 단계 9부터 실행시간이 기하급수적으로 늘어나게되서 실패함. ->> 효율성실패
     // 6. 3번은 암호전문가들이 구현해낼 수 있는 알고리즘 이라는 걸 깨닫게 되었고, 첫 번째 생각으로 푸는게 결국 솔루션이겠구나 생각이 됨.    

class Solution {
  public int solution(int n) {
      int answer = 0;
     
        boolean  discriminant;  //판별식
           
        for(int i=2; i<=n; i++){ // 2부터 시작
             discriminant = true; //판별식 D가 참일 때, 
             for(int j=2; j<i; j++){    
                if(i%j == 0){        //  i 가 j로 나누어 떨어진다면 ->i는 j의  배수이므로 이미 솟수가 아니게됨
                     discriminant = false;  //판별식을 만족하지 못하게 되므로
                    break;	   // 반복문을 빠져나가라.
                }
            }
               if( discriminant== true){//그리고 만약 판별식이 참이라면,
                answer++;  // 
            }        
        }
      return answer;
    }
}

//10초넘어가서 넘오래걸림..
//       for(n= 2; n < 100 ; n++){
//           {
//               for(int m= 2; m < 100; m ++){
//                    if(n%m==0){
//                        answer ++;
//                    }
//               }
//           }
//       }
//       return answer;
//   }
// } 
